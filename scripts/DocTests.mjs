// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Os from "os";
import * as Url from "url";
import * as Path from "path";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__List from "../src/Core__List.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "../src/Core__Array.mjs";
import * as RescriptCore from "../src/RescriptCore.mjs";
import * as Tools_Docgen from "@rescript/tools/npm/Tools_Docgen.mjs";
import * as Child_process from "child_process";
import * as Promises from "node:fs/promises";

var Path$1 = {};

var $$URL = {};

var Process = {};

var Fs$1 = {};

var $$Buffer = {};

var ChildProcess = {};

var OS = {};

var $$Node = {
  Path: Path$1,
  $$URL: $$URL,
  Process: Process,
  Fs: Fs$1,
  $$Buffer: $$Buffer,
  ChildProcess: ChildProcess,
  OS: OS
};

var dirname = Path.dirname(Url.fileURLToPath(import.meta.url));

var compilerDir = Path.join(dirname, "..", ".examples-tests");

var rescriptBin = Path.join(compilerDir, "node_modules", ".bin", "rescript");

var bscBin = Path.join(compilerDir, "node_modules", ".bin", "bsc");

var rescriptCoreCompiled = Path.join(compilerDir, "node_modules", "@rescript", "core", "lib", "ocaml");

function makePackageJson(coreVersion) {
  return "{\n  \"name\": \"test-compiler-examples\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@rescript/core\": \"file:rescript-core-" + coreVersion + ".tgz\",\n    \"rescript\": \"11.1.0-rc.7\"\n  }\n}\n";
}

var rescriptJson = "{\n  \"name\": \"dummy\",\n  \"sources\": {\n    \"dir\": \"dummy\",\n    \"subdirs\": true\n  },\n  \"bs-dependencies\": [\n    \"@rescript/core\"\n  ],\n  \"bsc-flags\": [\n    \"-open RescriptCore\"\n  ]\n}";

function prepareCompiler() {
  var corePath = Path.join(compilerDir, "..");
  if (!Fs.existsSync(compilerDir)) {
    Fs.mkdirSync(compilerDir);
  }
  Child_process.execFileSync("npm", [
        "pack",
        corePath
      ], {
        stdio: "ignore",
        cwd: compilerDir
      });
  var dict = JSON.parse(Fs.readFileSync(Path.join(corePath, "package.json")));
  var currentCoreVersion;
  if (!Array.isArray(dict) && (dict === null || typeof dict !== "object") && typeof dict !== "number" && typeof dict !== "string" && typeof dict !== "boolean") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "DocTests.res",
            129,
            9
          ],
          Error: new Error()
        };
  }
  if (typeof dict === "object" && !Array.isArray(dict)) {
    var s = dict["version"];
    if (!Array.isArray(s) && (s === null || typeof s !== "object") && typeof s !== "number" && typeof s !== "string" && typeof s !== "boolean") {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "DocTests.res",
              127,
              11
            ],
            Error: new Error()
          };
    }
    if (typeof s === "string") {
      currentCoreVersion = s;
    } else {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "DocTests.res",
              127,
              11
            ],
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "DocTests.res",
            129,
            9
          ],
          Error: new Error()
        };
  }
  Fs.writeFileSync(Path.join(compilerDir, "package.json"), makePackageJson(currentCoreVersion));
  Fs.writeFileSync(Path.join(compilerDir, "rescript.json"), rescriptJson);
  var dummyFolder = Path.join(compilerDir, "dummy");
  if (!Fs.existsSync(dummyFolder)) {
    Fs.mkdirSync(dummyFolder);
  }
  Child_process.execFileSync("npm", ["install"], {
        cwd: compilerDir
      });
  Child_process.execFileSync(rescriptBin, ["build"], {
        cwd: compilerDir
      });
}

prepareCompiler();

async function run(command, args, options) {
  return await new Promise((function (resolve, _reject) {
                var spawn = Child_process.spawn(command, args, options !== undefined ? Caml_option.valFromOption(options) : undefined);
                var stdout = [];
                var stderr = [];
                spawn.stdout.on("data", (function (data) {
                        stdout.push(data);
                      }));
                spawn.stderr.on("data", (function (data) {
                        stderr.push(data);
                      }));
                spawn.once("close", (function (code, _signal) {
                        resolve({
                              stdout: stdout,
                              stderr: stderr,
                              code: code
                            });
                      }));
              }));
}

var SpawnAsync = {
  run: run
};

function createFileInTempDir(id) {
  return Path.join(Os.tmpdir(), id);
}

async function compileTest(id, code) {
  var tempFileName = Path.join(Os.tmpdir(), id);
  await Promises.writeFile(tempFileName + ".res", code);
  var args = [
    tempFileName + ".res",
    "-I",
    rescriptCoreCompiled,
    "-w",
    "-3-109",
    "-uncurried",
    "-open",
    "RescriptCore"
  ];
  var match = await run(bscBin, args, undefined);
  var stderr = match.stderr;
  if (stderr.length > 0) {
    return {
            TAG: "Error",
            _0: stderr.map(function (e) {
                    return e.toString();
                  }).join("")
          };
  } else {
    return {
            TAG: "Ok",
            _0: match.stdout.map(function (e) {
                    return e.toString();
                  }).join("")
          };
  }
}

function extractDocFromFile(file) {
  var toolsBin = Path.join(Path.dirname(dirname), "node_modules", ".bin", "rescript-tools");
  var spawn = Child_process.spawnSync(toolsBin, [
        "doc",
        file
      ]);
  return Tools_Docgen.decodeFromJson(JSON.parse(spawn.stdout.toString()));
}

function getExamples(param) {
  var loop = function (_items, _acc) {
    while(true) {
      var acc = _acc;
      var items = _items;
      if (!items) {
        return acc;
      }
      var match = items.hd;
      switch (match.kind) {
        case "value" :
            _acc = {
              hd: {
                id: match.id,
                kind: "value",
                name: match.name,
                docstrings: match.docstrings
              },
              tl: acc
            };
            _items = items.tl;
            continue ;
        case "type" :
            _acc = {
              hd: {
                id: match.id,
                kind: "type",
                name: match.name,
                docstrings: match.docstrings
              },
              tl: acc
            };
            _items = items.tl;
            continue ;
        case "module" :
            _acc = {
              hd: {
                id: match.id,
                kind: "module",
                name: match.name,
                docstrings: match.docstrings
              },
              tl: acc
            };
            _items = Belt_List.concatMany([
                  items.tl,
                  Core__List.fromArray(match.items)
                ]);
            continue ;
        case "moduleAlias" :
            _acc = {
              hd: {
                id: match.id,
                kind: "moduleAlias",
                name: match.name,
                docstrings: match.docstrings
              },
              tl: acc
            };
            _items = Belt_List.concatMany([
                  items.tl,
                  Core__List.fromArray(match.items)
                ]);
            continue ;
        
      }
    };
  };
  return Core__List.toArray(loop(Core__List.fromArray(param.items), /* [] */0)).filter(function (param) {
              return param.docstrings.length > 0;
            });
}

function getCodeBlocks(example) {
  var loopEndCodeBlock = function (_lines, _acc) {
    while(true) {
      var acc = _acc;
      var lines = _lines;
      if (!lines) {
        return RescriptCore.panic("Failed to find end of code block for " + example.kind + ": " + example.id);
      }
      var hd = lines.hd;
      if (hd.trim().endsWith("```")) {
        return acc;
      }
      _acc = {
        hd: hd,
        tl: acc
      };
      _lines = lines.tl;
      continue ;
    };
  };
  var loop = function (_lines, _acc) {
    while(true) {
      var acc = _acc;
      var lines = _lines;
      if (!lines) {
        return acc;
      }
      var rest = lines.tl;
      if (lines.hd.trim().startsWith("```res")) {
        var code = loopEndCodeBlock(rest, /* [] */0);
        _acc = {
          hd: Core__List.toArray(Core__List.reverse(code)).join("\n"),
          tl: acc
        };
        _lines = rest;
        continue ;
      }
      _lines = rest;
      continue ;
    };
  };
  return Core__List.toArray(loop(Core__List.fromArray(Core__Array.reduce(example.docstrings, [], (function (acc, docstring) {
                            return acc.concat(docstring.split("\n"));
                          }))), /* [] */0));
}

async function runtimeTests(code) {
  var match = await run("node", [
        "-e",
        code
      ], {
        cwd: compilerDir,
        timeout: 2000
      });
  var exitCode = match.code;
  var stderr = match.stderr;
  var stdout = match.stdout;
  var std;
  var exit = 0;
  if (exitCode !== null) {
    if (exitCode === 0.0 && stderr.length > 0) {
      std = {
        TAG: "Ok",
        _0: stderr
      };
    } else if (exitCode === 0.0) {
      std = {
        TAG: "Ok",
        _0: stdout
      };
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    std = {
      TAG: "Error",
      _0: stderr.length > 0 ? stderr : stdout
    };
  }
  if (std.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: std._0.map(function (e) {
                    return e.toString();
                  }).join("")
          };
  } else {
    return {
            TAG: "Error",
            _0: std._0.map(function (e) {
                    return e.toString();
                  }).join("")
          };
  }
}

function indentOutputCode(code) {
  var indent = " ".repeat(2);
  return code.split("\n").map(function (s) {
                return indent + s;
              }).join("\n");
}

async function compilerResults() {
  var results = await Promise.all(getExamples(extractDocFromFile("src/RescriptCore.res")).map(async function (example) {
            var id = example.id.replaceAll(".", "_");
            var codes = getCodeBlocks(example);
            var results = await Promise.all(codes.map(async function (code, $$int) {
                      var id$1 = id + "_" + $$int.toString(undefined);
                      return [
                              code,
                              await compileTest(id$1, code)
                            ];
                    }));
            return [
                    example,
                    results
                  ];
          }));
  var examples = results.map(function (param) {
        var match = Core__Array.reduce(param[1], [
              [],
              []
            ], (function (acc, param) {
                var errors = acc[1];
                var oks = acc[0];
                var result = param[1];
                if (result.TAG === "Ok") {
                  return [
                          Belt_Array.concatMany([
                                oks,
                                [[
                                    param[0],
                                    result._0
                                  ]]
                              ]),
                          errors
                        ];
                } else {
                  return [
                          oks,
                          Belt_Array.concatMany([
                                errors,
                                [{
                                    TAG: "ReScript",
                                    error: result._0
                                  }]
                              ])
                        ];
                }
              }));
        return [
                param[0],
                [
                  match[0],
                  match[1]
                ]
              ];
      });
  var exampleErrors = await Promise.all(examples.map(async function (param) {
            var match = param[1];
            var nodeTests = await Promise.all(match[0].map(async function (param) {
                      var js = param[1];
                      return [
                              param[0],
                              js,
                              await runtimeTests(js)
                            ];
                    }));
            var runtimeErrors = Belt_Array.keepMap(nodeTests, (function (param) {
                    var output = param[2];
                    if (output.TAG === "Ok") {
                      return ;
                    } else {
                      return {
                              TAG: "Runtime",
                              rescript: param[0],
                              js: param[1],
                              error: output._0
                            };
                    }
                  }));
            return [
                    param[0],
                    runtimeErrors.concat(match[1])
                  ];
          }));
  exampleErrors.forEach(function (param) {
        var example = param[0];
        var cyan = function (s) {
          return "\x1b[36m" + s + "\x1b[0m";
        };
        var other = example.kind;
        var kind = other === "moduleAlias" ? "module alias" : other;
        var errorMessage = param[1].map(function (err) {
              if (err.TAG === "ReScript") {
                var err$1 = err.error.split("\n").filter(function (param, i) {
                        return i !== 2;
                      }).join("\n");
                return "\x1B[1;31merror\x1B[0m: failed to compile examples from " + kind + " " + cyan(example.id) + "\n" + err$1;
              }
              var indent = " ".repeat(2);
              return "\x1B[1;31mruntime error\x1B[0m: failed to run examples from " + kind + " " + cyan(example.id) + "\n\n" + indent + "\x1b[36mReScript\x1b[0m\n\n" + indentOutputCode(err.rescript) + "\n\n" + indent + "\x1b[36mCompiled Js\x1b[0m\n\n" + indentOutputCode(err.js) + "\n\n" + indent + "\x1B[1;31mstacktrace\x1B[0m\n\n" + indentOutputCode(err.error) + "\n";
            });
        errorMessage.forEach(function (e) {
              process.stderr.write(e);
            });
      });
  var someError = exampleErrors.some(function (param) {
        return param[1].length > 0;
      });
  if (someError) {
    return 1;
  } else {
    return 0;
  }
}

var exitCode = await compilerResults();

process.exit(exitCode);

var Docgen;

export {
  $$Node ,
  Docgen ,
  dirname ,
  compilerDir ,
  rescriptBin ,
  bscBin ,
  rescriptCoreCompiled ,
  makePackageJson ,
  rescriptJson ,
  prepareCompiler ,
  SpawnAsync ,
  createFileInTempDir ,
  compileTest ,
  extractDocFromFile ,
  getExamples ,
  getCodeBlocks ,
  runtimeTests ,
  indentOutputCode ,
  compilerResults ,
  exitCode ,
}
/* dirname Not a pure module */

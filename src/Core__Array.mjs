// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function make(length, x) {
  if (length <= 0) {
    return [];
  }
  var arr = new Array(length);
  arr.fill(x);
  return arr;
}

function fromInitializer(length, f) {
  if (length <= 0) {
    return [];
  }
  var arr = new Array(length);
  for(var i = 0; i < length; ++i){
    arr[i] = Curry._1(f, i);
  }
  return arr;
}

function equal(a, b, eq) {
  var len = a.length;
  if (len === b.length) {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === len) {
        return true;
      }
      if (!Curry._2(eq, a[i], b[i])) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function compare(a, b, cmp) {
  var lenA = a.length;
  var lenB = b.length;
  if (lenA < lenB) {
    return -1;
  } else if (lenA > lenB) {
    return 1;
  } else {
    var _i = 0;
    while(true) {
      var i = _i;
      if (i === lenA) {
        return 0;
      }
      var c = Curry._2(cmp, a[i], b[i]);
      if (c !== 0) {
        return c;
      }
      _i = i + 1 | 0;
      continue ;
    };
  }
}

function indexOfOpt(arr, item) {
  var index = arr.indexOf(item);
  if (index !== -1) {
    return index;
  }
  
}

function lastIndexOfOpt(arr, item) {
  var index = arr.lastIndexOf(item);
  if (index !== -1) {
    return index;
  }
  
}

function reduce(arr, init, f) {
  return arr.reduce(f, init);
}

function reduceWithIndex(arr, init, f) {
  return arr.reduce(f, init);
}

function reduceRight(arr, init, f) {
  return arr.reduceRight(f, init);
}

function reduceRightWithIndex(arr, init, f) {
  return arr.reduceRight(f, init);
}

function findIndexOpt(array, finder) {
  var index = array.findIndex(finder);
  if (index !== -1) {
    return index;
  }
  
}

function swapUnsafe(xs, i, j) {
  var tmp = xs[i];
  xs[i] = xs[j];
  xs[j] = tmp;
}

function shuffle(xs) {
  var len = xs.length;
  for(var i = 0; i < len; ++i){
    swapUnsafe(xs, i, Js_math.random_int(i, len));
  }
}

function toShuffled(xs) {
  var result = xs.slice();
  shuffle(result);
  return result;
}

function filterMap(a, f) {
  var f$1 = Curry.__1(f);
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    var v$1 = f$1(v);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

function keepSome(__x) {
  return filterMap(__x, (function (x) {
                return x;
              }));
}

function findMap(arr, f) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === arr.length) {
      return ;
    }
    var r = Curry._1(f, arr[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

export {
  make ,
  fromInitializer ,
  equal ,
  compare ,
  indexOfOpt ,
  lastIndexOfOpt ,
  reduce ,
  reduceWithIndex ,
  reduceRight ,
  reduceRightWithIndex ,
  findIndexOpt ,
  filterMap ,
  keepSome ,
  toShuffled ,
  shuffle ,
  findMap ,
}
/* No side effect */
